#!/usr/bin/env python

import pyelliptic
import re
import sys

from base64 import b64decode

def usage():
    print "Usage: " + sys.argv[0] + " <keyfile>"
    print ""
    print "<keyfile> is a text file containing at least two lines,   "
    print "one beginning with 'pw_secret = ' followed by a secret    "
    print "key and another beginning with 'pw_pubkey = ' followed by "
    print "a public key. This file can be generated by pw_keygen.    "
    print "Then this script reads from stdin and replaces encrypted  "
    print "passwords with unencrypted ones. You can redirect cowrie  "
    print "logs directly into this script without modification.      "

def error(m):
    usage()
    print ""
    print "error: " + m
    exit(1)

# Sanity check command line argument
if len(sys.argv) < 2:
    error("no keyfile argument provided")

if len(sys.argv) > 2:
    error("too many arguments")

# Open the keyfile and look for the keys

def read_file(keyword):
    key = ""
    keyfile = open(sys.argv[1])
    for line in keyfile:
        regex = keyword + " *= *['\"]?([A-Za-z0-9=+/]+)"
        m = re.search(regex , line)
        if m:
            if len(key) > 0:
                error("more than one secret key found!")
            key = m.group(1)
    return b64decode(key)
        
seckey = read_file("pw_secret")
pubkey = read_file("pw_pubkey")

if seckey == "":
    error("no secret key found in file")
if pubkey == "":
    error("no secret key found in file")


## Decrypt any encrypted blobs on stdin

actor = pyelliptic.ECC(privkey=seckey, pubkey=pubkey)

for line in sys.stdin:
    m = re.search("[A-za-z0-9=+/]{184}", line)
    ciphertext = m.group(0)    
    plaintext = actor.decrypt(b64decode(ciphertext))
    print line.replace(ciphertext, plaintext)


